#!/usr/bin/env bash

# A wrapper around find that pretties up the results and adds some additional information.

shopt -s extglob

find_args=()
show_perm=0
show_owner=0
show_size=0
show_time=0
stat_user_args='- -'

has_invalid_param=0
for arg in "$@"; do
	case "$arg" in
		# These arguments can have side effects, or can alter the output of find. This might break our parsing of its
		# output, so block this.
		-delete|-exec|-execdir|-fls|-fprint|-fprint0|-fprintf|-ls|-ok|-okdior|-print|-print0|-printf|-prune)
			has_invalid_param=1
			echo >&2 "$arg is not permitted for ffind, use regular find instead"
		;;

		+noperm?(ission)?(s)) show_perm=0 ;;
		+perm?(ission)?(s)) show_perm=1 ;;

		+noowner?(s)) show_owner=0 ;;
		+owner?(s))
			show_owner=1

			stat_args_owner="%u %g"

			current_user="$(id -u)"
			current_groups=" $(id -G) "

			longest_user=$(cat /etc/passwd | cut -d: -f3 | wc -L)
			longest_group=$(cat /etc/group | cut -d: -f3 | wc -L)
		;;
		+owner?(s)?(as)name?(s))
			show_owner=1

			stat_args_owner="%U %G"

			current_user="$(whoami)"
			current_groups=" $(groups) "

			longest_user=$(cat /etc/passwd | cut -d: -f1 | wc -L)
			longest_group=$(cat /etc/group | cut -d: -f1 | wc -L)
		;;

		+nosize) show_size=0 ;;
		+size) show_size=1 ;;

		+no?(c)time) show_time=0 ;;
		+?(c)time) show_time=1 ;;

		+*)
			has_invalid_param=1
			echo >&2 "$arg is not a valid argument for ffind"
			echo
		;&

		+help)
			echo "Usage: $0 [OPTION]... [ARGUMENT FOR FIND]..."
			echo
			echo "  +perm           show the permissions"
			echo "  +size           show the (human-readable) sizes"
			echo "  +time           show the last modified times"
			echo "  +owner          show the ids of the owners (user and group)"
			echo "  +ownerasname    show the names of the owners (user and group)"
		;;

		*)
			find_args=("${find_args[@]}" "$arg")
		;;
	esac
done
[ "$has_invalid_param" -eq 0 ] || exit 1

# Build the format for the stat call.
stat_args=()
[ "$show_perm" -eq 1 ] && stat_args=("${stat_args[@]}" '%a')
[ "$show_owner" -eq 1 ] && stat_args=("${stat_args[@]}" "${stat_args_owner[@]}")
[ "$show_size" -eq 1 ] && stat_args=("${stat_args[@]}" '%s')
[ "$show_time" -eq 1 ] && stat_args=("${stat_args[@]}" '%Y')
stat_args=("${stat_args[@]}" '%N') # Path + symlink. Always present. Must be last, because it is of variable size.
stat_args="${stat_args[@]}"

source nerdfonts_icons_fa
source nerdfonts_icons_oct
while IFS= read -r -d '' path; do
	# Single stat, containing all items needed for the requested options.
	stats=($(stat -c "$stat_args" "$path"))
	statsidx=0

	# Figure out what this path is, and what the appropriate icon is for that.
	if [ -d "$path" ]; then
		[ -h "$path" ] && icon="$i_oct_file_symlink_directory" || icon="$i_oct_file_directory"
	elif [ -f "$path" ]; then
		if [ -h "$path" ]; then
			icon="$i_oct_file_symlink_file"
		else
			type="$(file --brief "$path")"
			case "$type" in
				*compressed*) icon="$i_oct_file_zip" ;;
				*image*) icon="$i_oct_file_media" ;;
				*audio*) icon="$i_oct_file_media" ;;
				*video*) icon="$i_oct_file_media" ;;
				*text*) icon="$i_fa_file_o" ;;
				*empty*) icon="$i_fa_file_o" ;;
				*document*) icon="$i_oct_file_pdf" ;;
				*socket*) icon="$i_mdi_network" ;;
				*) icon="$i_oct_file_binary" ;;
			esac
		fi
	elif [ -h "$path" ]; then
		# This is a broken symlink.
		icon="$i_oct_file_symlink_file"
	fi
	printf '%s%s%s' "$color_fg_cyan" "$icon" "$color_reset"

	### Permissions.
	if [ "$show_perm" -eq 1 ]; then
		perm="${stats[statsidx++]}"

		# Color the permissions based on what this means in practice for the current user.
		perm_color=
		if [ ! -r "$path" ]; then
			perm_color="$color_fg_red"
		elif [ ! -x "$path" ] && [ -d "$path" ]; then
			perm_color="$color_underline$color_fg_yellow" # Cannot list the files in the directory.
		elif [ ! -w "$path" ]; then
			perm_color="$color_fg_yellow"
		else
			if [ -x "$path" ] && [ ! -d "$path" ]; then
				perm_color="$color_fg_blue"
			fi
			if [ -k "$path" ] && [ ! -O $(id -u) ]; then
				perm_color="$color_underline$perm_color" # Cannot rename/delete the path (sticky bit).
			fi
		fi

		[ "${#perm}" -eq 3 ] && padding=' ' || padding=
		printf ' %s%s%s%s' "$padding" "$perm_color" "$perm" "$color_reset"
	fi

	### Ownership.
	if [ "$show_owner" -eq 1 ]; then
		user="${stats[statsidx++]}"
		group="${stats[statsidx++]}"

		# Color based on whether the current is (part of) these.
		[ "$current_user" == "$user" ] && user_color= || user_color="$color_fg_red"
		[[ "$current_groups" == *" $group "* ]] && group_color= || group_color="$color_fg_red"

		printf " %s%${longest_user}s%s:%s%-${longest_group}s%s" \
			"$user_color" "$user" "$color_reset" \
			"$group_color" "$group" "$color_reset"
	fi

	### Size.
	if [ "$show_size" -eq 1 ]; then
		size="${stats[statsidx++]}"

		if [ -f "$path" ] && [ ! -h "$path" ]; then
			size="$(echo "$size" | numfmt --to=iec)"
		else
			size=
		fi

		printf ' %4s' "$size"
	fi

	### Last modified time.
	if [ "$show_time" -eq 1 ]; then
		ctime="${stats[statsidx++]}"

		printf ' %13s' "$(date --date="@$ctime" +'%b %e %H:%M')"
	fi

	# Print the path as it was received from find.
	printf ' %s' "$path"

	# If the path is a symbolic link, show the target.
	name="$path"
	if [ -h "$path" ]; then
		# The first two are the path (quoted), and the literal '->' (not quoted). We ignore both.
		eval "linksto=${stats[statsidx + 2]}" # the target path is quoted, so eval to unquote.

		# If the path does not exist, this means the symlink is broken.
		if [ ! -e "$path" ]; then
			linksto="${color_fg_red}${linksto}${color_reset}"
		fi

		printf ' -> %s' "$linksto"
	fi

	printf '\n'
done < <(find "${find_args[@]}" -printf '%p\0' | sort -z)
