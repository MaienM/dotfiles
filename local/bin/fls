#!/usr/bin/env bash

# A fancier-looking ls-like command, based on fancy find.

set -e

push() {
	var="$1"
	shift 1
	eval "tmp=(\"\${$var[@]}\")"
	tmp=("${tmp[@]}" "$@")
	eval "$var=(\"\${tmp[@]}\")"
}

# Arguments to be passed to each ffind call.
ffind_args=()
# The target paths.
targets=()

# Keep track of ls flags that can only be processed once all arguments have been processed.
ls_all=0
ls_almost_all=0

# Parse arguments
args=($(getopt -o '1aABdhlI:nps' -l 'all,almost-all,directory,human-readable,ignore:,indicator-style:numeric-uid-gid,size' -n "$0" -- "$@"))
i=0
while [ "$i" -le "${#args[@]}" ]; do
	arg="${args[i++]}"
	case "$arg" in
		# Try to convert ls arguments to find arguments, where possible.
		-1) ;;
		-a|--all)
			ls_all=1
		;;
		-A|--almost-all)
			ls_almost_all=1
		;;
		-d|--directory)
			push ffind_args '-type' 'd'
		;;
		-h|--human-readable) ;;
		-l)
			push ffind_args '+perm' '+ownerasname' '+size' '+time'
		;;
		-I|--ignore)
			push ffind_args '-not' '-name' "${args[i++]}"
		;;
		--indicator-style) $((i++)) ;;
		-n|--numeric-uid-gid)
			push ffind_args '+perm' '+owner' '+size' '+time'
		;;
		-p) ;;
		-s|--size)
			push ffind_args '+size'
		;;

		# End of arguments. Add the remaining arguments as targets, and stop processing.
		--)
			eval "targets=(\"\${targets[@]}\" ${args[@]:i})"
			break
		;;

		# Arguments that start with a plus are options for ffind, and should be passed on.
		+*)
			push ffind_args "$arg"
		;;

		# Doesn't appear to be an option, so treat it as a path that should be listed.
		*)
			push targets "$arg"
		;;
	esac
done

# Process extra ls flags.
if [ "$ls_all" -eq 0 ] && [ "$ls_almost_all" -eq 0 ]; then
	push ffind_args '-not' '-name' '.*'
fi

# If no targets are given, default to the current directory (as ls does).
if [ "${#targets[@]}" -eq 0 ]; then
	targets=("$PWD")
fi

# Determine whether at least one of the arguments is a directory. If this is the case, we need to print headers above
# each ffind command. If not, we can opt for a more compact syntax.
listing_a_dir=false
for path in "${targets[@]}"; do
	[ -d "$path" ] && listing_a_dir=true
done

isfirst=true
for path in "${targets[@]}"; do
	if [ "${#targets[@]}" -gt 1 ] && $listing_a_dir; then
		$isfirst || printf '\n'
		printf '%s:\n' "$path"
	fi
	isfirst=false

	if [ -d "$path" ]; then
		(
			if [ "$ls_all" -eq 1 ]; then
				ffind "$path/." "$path/.." -maxdepth 0 "${ffind_args[@]}"
			fi
			ffind "$path" -mindepth 1 -maxdepth 1 "${ffind_args[@]}"
		) | awk -v "needle=$path/" '{ sub(needle, ""); print }'
	else
		ffind "$path" -maxdepth 0 "${ffind_args[@]}"
	fi
done
